import { State, StateAndScore } from "../state/state";
import {
  buildHighPerfConfiguration,
  HighPerfConfiguration,
  Hyperparameters,
  Parameters,
} from "../../eingabe/configuration.ts";
import { generateRandomState } from "../common/initialization";
import { minBy, times } from "lodash-es";
import { stateScore } from "../score/state";
import type { Pool } from "workerpool";
import * as workerpool from "workerpool";
// @ts-expect-error tsc doesn't understand special web worker base64 urls generated by vite
import WorkerURL from "./worker?url&worker";
import { fromState, Result } from "../state/result.ts";
import { Progress } from "../state/progress.ts";

export type ProgressFun = (progress: Progress) => void;

export async function runCrappySimulatedAnnealing(
  parameters: Parameters,
  hyperparameters: Hyperparameters,
  progressFun: ProgressFun = () => {},
): Promise<[Result, Progress]> {
  const start = new Date();

  const configuration = buildHighPerfConfiguration(parameters);

  // const WorkerURL = new WorkerUrl(new URL("../../../../dist/worker.js", import.meta.url));
  // const script = __dirname + "/worker.js";
  const workerPool = workerpool.pool(WorkerURL, {
    workerOpts: {
      type: import.meta.env.PROD ? undefined : "module",
    },
  });

  let states: StateAndScore[] = times(hyperparameters.populationSize, () =>
    andScore(generateRandomState(configuration), configuration),
  );
  const bestStates: StateAndScore[] = states;
  const bestGenerations: number[] = Array(hyperparameters.populationSize).fill(0);

  let statesChecked = 0;
  let bestState = minBy(states, (it) => it.score)!;
  let genOfBestState = 0;

  for (let gen = 0; gen < hyperparameters.maxGenerations; gen++) {
    const { states: newStates, checked } = await generateNewStates(states, configuration, hyperparameters, workerPool);
    statesChecked += checked;

    for (let i = 0; i < newStates.length; i++) {
      const newState = newStates[i];
      const oldState = bestStates[i];
      if (newState.score < oldState.score) {
        bestGenerations[i] = gen;
        bestStates[i] = newState;
      } else if (gen > bestGenerations[i] + hyperparameters.restartGenerationLimit) {
        // if no improvement for a while, reset individual to global best
        bestGenerations[i] = gen;
        newStates[i] = bestState;
      } else if (newState.score > oldState.score && Math.random() < hyperparameters.acceptanceProbability) {
        // if worse than before, randomly decide whether to keep worse state
        // TODO probability is backwards (should be called rejectionProbability)
        newStates[i] = oldState;
      }
    }

    states = newStates;
    const newBestState = minBy(states, (it) => it.score)!;

    if (newBestState.score < bestState.score) {
      bestState = newBestState;
      genOfBestState = gen;
    }

    progressFun({ duration: (new Date().getTime() - start.getTime()) / 1000, checked: statesChecked });

    if (gen > genOfBestState + hyperparameters.globalGenerationLimit) {
      break;
    }
  }

  const result = fromState(parameters, configuration, bestState.state);
  const progress = { duration: (new Date().getTime() - start.getTime()) / 1000, checked: statesChecked };
  return [result, progress];
}

async function generateNewStates(
  states: StateAndScore[],
  configuration: HighPerfConfiguration,
  hyperparameters: Hyperparameters,
  workerpool: Pool,
): Promise<{ states: StateAndScore[]; checked: number }> {
  const newStates: StateAndScore[] = [];
  let totalChecked = 0;

  const promises: Promise<{ state: StateAndScore; checked: number }>[] = [];

  for (const oldState of states) {
    // noinspection ES6MissingAwait
    const promise: Promise<{ state: StateAndScore; checked: number }> =
      Math.random() < hyperparameters.smartMutationRate
        ? workerpool.exec("mutateVerySmart", [oldState.state, configuration])
        : // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (workerpool.exec("mutateRandom", [oldState.state, configuration]) as any);
    promises.push(promise);
  }

  const results = await Promise.all(promises);
  for (const result of results) {
    newStates.push(result.state);
    totalChecked += result.checked;
  }

  return { states: newStates, checked: totalChecked };
}

function andScore(state: State, configuration: HighPerfConfiguration): StateAndScore {
  return { state, score: stateScore(state, configuration) };
}
